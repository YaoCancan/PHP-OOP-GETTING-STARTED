# PHP OOP-GETTING-STARTED


* Created by CARL
* first time update time: 2015/1/18/19:36:39
* Last-Modified: 2016/11/6/21:43

---
### #定义一个类(类：类别)
```
class 类名
{
   属性;
   方法;
}
```
### #属性：变量

  
```
变量：在类的外面定义的变量
属性：在类的里面定义的变量
```
### #定义属性的格式

  
```
访问控制修饰符 $属性名;
访问控制修饰符 $属性名 = 值;
```
### #方法：函数
  
```
函数：在类的外面定义的函数
方法：在类的里面定义的函数
```
### #定义方法的格式
  
```
访问控制修饰符 function 方法名(参数...)
  {
     逻辑代码;
     return 值;
  }
```
### #编写类时注意
>   1. 类是由两部分组成：属性、方法
>   2. 类里只能出现属性和方法，逻辑代码必须出现在方法里
>   3. 类里可以有多个属性和方法
>   4. 类里可以只有方法，没有属性
>   5. 类里可以只有属性，没有方法
>   6. 类里的多个属性和方法在定义上，没有先后顺序
>   7. 通常情况下，一文件中只定义一个类
>   8. 如果一个文件中只有一个类的时候，那么这个类名与文件名相同

### #驼峰命名规则
>   1. 小驼峰命名规则
>     如果名字由多个单词组成，那么第一个单词的首字母小写，其后每个单词的首字母必须大写
>     userInfo  userName   userSex  age
>   2. 大驼峰命名规则
>     如果名字由多个单词组成，那么每个单词的首字母必须全部大写
>     UserInfo  UserName   Person
>   小驼峰：变量名、数组名、函数名、属性名、方法名
>   大驼峰：类名
>   全部大写：常量
--------------------------------------------------------------------------------

类和对象的转换关系：
         抽象(想象)          实例化
对象------------->类------------->对象
现实存在的事物------>描述成类------>(抽象ing)------>程序中虚拟的对象
个人意见。
--------------------------------------------------------------------------------

### #实例化对象格式
  $对象名 = new 类名();
  $对象名 = new 类名(值, 值, 值);
### #通过对象调用属性
  赋值
    $对象->属性 = 值;
  取值
    $变量 = $对象->属性;
    echo "值为：{$对象->属性}";
### #通过对象调用方法
  $对象->方法名();
  $对象->方法名(值,值,值...);
  $变量 = $对象->方法名(值,值,值...);
--------------------------------------------------------------------------------

### #构造函数
  1. 构造函数方法名与类名相同
  2. 在实例化该类的对象时，由系统自动调用一次
  3. 构造函数没有返回值
  4. 不建议通过对象调用构造函数
  5. 一个类中，最多只能有一个构造函数，最少没有
  6. 构造函数的作用：初始化
### #定义构造函数的格式
  访问控制修饰符 function 类名()
  {}
  访问控制修饰符 function __construct()
  {}
  建议：建议大家写__construct()

### #析构函数(了解)
  1. 方法名固定__destruct()
  2. 当前类的对象被销毁时，由系统自动调用一次
  3. 同一类最多能只有一个析构函数
  4. 析构函数作用：释放无用内存
--------------------------------------------------------------------------------

### #this关键字：代表了当前类的对象，在类的方法中，想要调用其他属性和方法时，必须要使用this
  调用属性
    赋值
      $this->属性 = 值;
    取值
      $变量 = $this->属性;
  调用方法
    $this->方法();
    $this->方法(值,值,值...);
    $变量 = $this->方法(值,值,值...);
来源于同一类的多个对象彼此间是独立的

### #类和对象的关系
  1. 类是对象的模板
  2. 对象是类的实例

### #常量：固定不变的值
  1. 在类外部定义常量
    define(常量名, 常量值);
  2. 在类的内部定义常量(常量属性)
    const 常量名 = 常量值;
### #调用常量属性
  1. 方法里调用常量
    self::常量名;
  2. 类外面调用常量
    类名::常量名;
--------------------------------------------------------------------------------
### #克隆对象
###### #对象之间的赋值操作
  $对象1 = $对象2;
    对象1与对象2对应的是同一个内存空间
    对象1与对象2是同一对象的两个对象
#对象之间的克隆操作
  $对象1 = clone $对象2;
    对象1与对象2对应的是不同的两个内存空间
    对象1与对象2是两个完全独立的对象
--------------------------------------------------------------------------------
### #static关键字
#变量：静态变量(静态属性)多个同名的静态变量，在内存中只有一个副本(省内存)
#静态变量(静态属性)的定义格式
  1. 静态变量
    static $变量名 = 值;
  2. 静态属性
    访问控制修饰符 static $属性 = 值;
#调用静态属性
  类名::属性 = 值;
  $变量 = 类名::属性;
#静态方法的定义格式
  访问控制修饰符 static function 方法名(参数...)
  {}
#调用静态方法的格式：通过类名直接调用
  类名::方法名();
  类名::方法名(值,值,值...);
  $变量 = 类名::方法名(值,值,值...);
#调用类里的属性和方法的途径
  类外
    静态
       类名::属性;
       类名::方法();
    非静态
      $对象 = new 类名();
      $对象->属性;
      $对象->方法();
  类内
    静态
      self::$属性;
      self::方法();
    非静态
      $this->属性;
      $this->方法();
#静态方法注意：
  1. 静态方法中不能出现this关键字
  2. 静态方法只能访问静态成员
--------------------------------------------------------------------------------
### #继承：子类继承父类
  作用：解决了代码重用问题(省代码)
  代表父亲的类：父类、超类、基类
  代表孩子的类：子类、派生类
#继承的语法格式
  class 父类
  {}
  class 子类 extends 父类
  {}
  class 子类 extends 父类
  {}
#注意：
  1. 一个子类最多只能有一个父类
  2. 一个父类可以有多个子类
  3. 子类可以继承父类的：public、protected
  4. 当实例化子类对象时，将调用子类自己的构造函数，如果子类没有构造函数，那么将调用父类的构造函数
--------------------------------------------------------------------------------
### #方法重写override
  1. 子类中存在与父类完全一样的方法
  2. 方法重写只需方法名完全相同
  3. 方法重写，参数可以不同
  4. 方法重写，返回值可以不同
#方法重写调用的特点
  实例化子类对象调用重写的方法时，那么将调用子类自己的方法
--------------------------------------------------------------------------------
### #访问控制修饰符：访问控制
  public：公有(没有限制)
  protected：受保护(只能在类的内部访问)
  private：私有(只有在本类的内部才可访问)
#访问控制修饰符权限
                  类内   类外   子类内    子类外
public          是     是        是           是
protected    是     否        是           否
private         是     否        否           否

#缺省的访问权限：什么也不写
  1. 访问级别与public相同
  2. "缺省"只能修饰给方法(php中不允许出现缺省的属性)
#var的访问权限
  1. 访问级别与public相同
  2. var只能施加给属性
#子类可以继承父类的：public、protected
#方法重写override：子类中存在与父类完全一样的方法
#面向对象三大特征
  继承：子类继承父类，子类可以共用父类里的代码
  封装：将具有类似功能方法，放到一个统一的类里
  多态：多个子类来源于同一父类，但却表现出了不同的状态
#子父类的构造函数(实例化子类对象)
  1. 调用子类自己的构造函数
  2. 如果子类没有构造函数，那么将调用父类的构造函数
--------------------------------------------------------------------------------
### #final最终
  类：final类(防继承)
    final class 类名
    {}
  方法：final方法(防重写)
    访问控制修饰符 fina function 方法名(参数....)
    {}
--------------------------------------------------------------------------------
### #abstract抽象
  类：抽象类
    如果一类中包含一个或多个抽象方法的话，那么这个类就叫抽象类
      absract class 类名
      {}
  方法：抽象方法
    只有方法名，没有方法体
      访问控制修饰符 abstract function 方法名(参数...);
#抽象注意：
  1. 子类必须重写父类中所有抽象方法
  2. 如果子类不重写，那么子类也将成为一个抽象类
  2. 抽象类中可以有普通方法
  3. 抽象类中可以没有抽象方法
  4. 抽象类不能实例化
  5. 抽象类可以继承其他类
--------------------------------------------------------------------------------
### #接口interface：就是一个特殊的抽象类
  如果一个抽象类中所有的方法都是抽象方法的话，那么这个类就可以定义成接口
#定义接口的格式
  interface 借口名
  {
      public function 方法名(参数...);
      public function 方法名(参数...);
      public function 方法名(参数...);
  }
#子类实现接口
  class 子类 implements 接口名
  {}
  class 子类 implements 接口名,接口名...
  {}
  class 子类 extends 父类 implements 接口名,接口名...
  {}
#接口注意：
  1. 接口本身就是抽象的，方法前不用加abstract
  2. 接口里的方法，只能是public
  2. 接口中没有构造函数
  3. 接口不能实例化
  4. 子类必须重写接口中所有的抽象方法，否则子类将变成抽象类
  5. 子类可以同时实现多个接口
  6. 子类既可以继承父类，也可以实现多个接口
  7. 接口不可以继承其他类
  8. 接口可以继承其他接口

### 总结：
---------必须掌握-------------
1. 面向对象概念
2. 定义类、属性、方法
3. 构造函数
4. 对象
5. this关键字
6. 常量
7. static关键字
8. 继承
9. 访问控制修饰符

---------了解学习-------------
1. 析构函数
2. 魔术方法
3. 方法重写override
4. abstract抽象
5. interface接口
--------------------------------------------------------------------------------

### #魔术方法(了解)
1. 调用一个不存在的属性
   public function __get($key){}
2. 给一个不存在的属性赋值
   public function __set($key,$value){}
3. 调用一个不存在的方法
   public function __call($key,$param){}
4、克隆对象(注意)
   public function __clone(){}
5、检测一个不存在的属性
   public function __isset($key){}
6、销毁一个不存在的属性
   public function __unset($key){}
--------------------------------------------------------------------------------
